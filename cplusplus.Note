c/c++基础
=

1.c和c++区别？

面向对象/过程、重载、模板、库函数(c松散,c++紧致)、struct

c适合要求代码体积小的，效率高的场合，如嵌入式；c++适合更上层的，复杂的；


2.static关键词起什么作用？

隐藏。 当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，故使用static在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。

保持变量内容的持久。存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量。

默认初始化为0.全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00

在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。



3.new和malloc的区别？

（1）new、delete 是操作符，可以重载，只能在C++中使用。 

（2）malloc、free 是函数，可以覆盖，C、C++中都可以使用。 

（3）new 可以调用对象的构造函数，对应的delete 调用相应的析构函数。 

（4）malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数 

（5）new、delete 返回的是某种数据类型指针，malloc、free 返回的是void 指针。 

malloc 申请的内存空间要用free 释放，而new 申请的内存空间要用delete 释放，不要混用。 因为两者实现的机理不同。 

malloc最大能申请多少内存：内存碎片会影响到你“一次”申请到的最大内存空间。如果不是连续的内存区域，malloc会失败。系统也会限制你的程序使用malloc申请到的最大内存。Windows下32位程序如果单纯看地址空间能有4G左右的内存可用，不过实际上系统会把其中2G的地址留给内核使用，所以你的程序最大能用2G的内存。除去其他开销，你能用malloc申请到的内存只有1.9G左右。




4.说一说C与C++的内存分配方式？
从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，如全局变量，static变量。

在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

从堆上分配（动态内存分配）程序在运行的时候用malloc或new申请任意多少的内存，程序员负责在何时用free或delete释放内存。动态内存的生存期自己决定，使用非常灵活。



5.什么是栈溢出？哪些情况下比较容易出现栈溢出？

栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，栈存放超过了其大小的数据

函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。

局部静态变量体积太大

解决方案：把递归转换成非递归；使用static对象、堆内存替代nonstatic局部对象；增加栈内存的数目



6.“#include”后面跟引号与尖括号的区别？

对于#include <a.h> ,编译器从标准库路径开始搜索 a.h对于#include "a.h" ,编译器从用户的工作路径开始搜索 a.h



7.内存越界访问？

内存越界访问有两种：一种是读越界，即读了不属于自己的数据，如果所读的内存地址是无效的，程序就立即崩溃。如果所读的内存地址是有效的，在读的时候不会出现问题，但是由于读到的数据是随机的，他会产生不可预料的后果，另一种是写越界，又叫缓冲区溢出。所写的数据是随机的，他也会产生不可预料的后果。



8.如果给指针加1或减1 ，实际上是加上或减去指针所指向的数据类型大小。


9.字节顺序
大端模式：高位字节数据存放在低地址处，低位字节数据存放在高地址处。
小端模式：低位字节数据存放在内存低地址处，高字节字节数据存放在内存高地址处
如：long n=0x11223344
模式        第1字节     第2字节    第3字节      第4字节
大端模式    0x11        0x22        0x33        0x44             
小端模式    0x44        0x33        0x22        0x11
#define BIG_ENDIAN 0
#define LITTLE_ENDIAN 1
int TestByteOrder(){
    short int word = 0x0001;
    char *byte = (char *) &word;
    return (byte[0] ? LITTLE_ENDIAN : BIG_ENDIAN);
}

10.valotile作用？
告诉编译器不要把变量优化到寄存器中。在开发多线程的程序是，如果这些线程共享一些全局变量，这些全局变量最好使用valotile修饰。这样可以避免因为编译器优化而引起的错误。下面是volatile变量的几个例子：
1) 并行设备的硬件寄存器（如：状态寄存器）
2) 一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)
3) 多线程应用中被几个任务共享的变量

一个参数既可以是const还可以是volatile，一个例子是只读的状态寄存器，它是volatile因为它可能被意想不到地改变，是const因为程序不应该试图去修改它。一个指针可以是volatile，一个例子是当一个中服务子程序修该一个指向一个buffer的指针时。

const和volatile是否可以同时修饰一个变量？有什么含义？
答案:如果一个变量不会被本程序改变，通常可能给它加上const，但如果该变量可能被其他程序改变而本程序又在检测这个变量的值，就需要给它加上volatile，于是变量就同时有volatile和const了，这个时候i具有const和volatile的双重属性。i变量不可以在编译过程中被程序代码修改，同时编译器不得对i进行优化编译。



11.在传递数组参数时，数组退化为指针(及按引用传递)，此时用sizeof是无法获取数据的大小。 
C/C++中数组是内置的数据类型，但不是基础数据类型而是构造数据类型，语义上是有限个占据连续物理空间的相同数据元素的有序集合。
数组名代表了存放该数组的那块内存，它是这块内存的首地址。这就说明了数组名是一个地址，是一个不可修改的常量。数组名跟枚举常量一样，都属于符号常量。数组名这个符号，就代表了那块内存的首地址。不是数组名的值是那块内存的首地址，而是数组名这个符号本身就代表了首地址这个地址值。
extern修饰的变量在连接的时候只找寻同名的标号，不检查类型
1.系统会为"指针名"分配空间(4字节)用于存指向地址
2.系统不为"数组名"分配地址,数组名就是一个地址空间的别名.
char *a = "123456"; a是指针，它有自己的空间(假设该空间首地址是0xaaaaaa00也就是&a),里面存的是字符串"123456"的地址
extern char a[];a被声明为数组了,那么好,在这个文件中a就代表一段地址空间的别名了,就是0xaaaaaa00的别名
char c = a[2];那么a[2]相当于对0xaaaaaa02空间解引用,即取出0xaaaaaa02空间的数

12.C与C++各自是如何定义常量的？有什么不同？
C中是使用宏#define定义， C++使用const来定义。


const表示只读,默认内部连接所以必须被初始化，其作用域为此文件，编译器经过类型检查后直接在编译时替换。

const是有数据类型的常量，而宏常量没有，编译器可以对前者进行静态类型安全检查，对后者仅是字符替换，没有类型安全检查，而且在字符替换时可能会产生意料不到的错误（边际效应）。

有些编译器可以对const常量进行调试， 不能对宏调试。

const无法代替宏作为卫哨来防止文件的重复包含。

const这个常量修饰是对于编写代码的程序员而言的，编译器通过类型检测等编译期手段来控制常量不能被改变。编译器对待常量和变量是不一样的。虽然编译器为常量i分配了一个地址，但是常量并不储存在那个地址上，而是用一个立即数直接代替它。

const关键字至少有以下作用：
　　（1）欲阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；
　　（2）对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；
　　（3）在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
　　（4）对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
　　（5）对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。

13.C++中引用和指针的区别？
a. 初始化：指针可以不初始化；引用必须在定义时初始化
b. 非空性：指针可以为NULL，因而指针可能是无效的；引用不能为空，因而引用总是有效的
c. 内存占用：指针要占用内存，引用不占     -> 引用只是一个逻辑概念，通常在编译时就优化掉了
d. 可修改性：指针可以重新指向其它变量；引用不可以
不能建立数组引用。即数组的元素不能是引用。
(1)引用只是个符号（名字），不是变量，不占内存，如果可以建立引用数组，那么对引用使用取址运算符 &就有了二义性。
(2)引用不支持传统意义的复制，传统意义的复制：
int a = b;
a和b在内存中分别占用，内容一致。
如果 int &a = b;
因此这种复制，内存中a并不分配新的内存，自然会错误。
引用初始化之后就不可以更改， 当然不可以复制

C++中引用是编译器通过指针实现的，但这个实现在语言层面对程序员做了透明化处理。

14.静态局部变量什么时候分配内存，什么时候初始化？

分配内存就算是创建了变量，声明不算创建变量，编译时分配内存，在第一次调用函数的时候初始化


15.在C++ 程序中调用被 C编译器编译后的函数，为什么要加 extern "C"?
C++语言支持函数重载，C语言不支持函数重载。函数被C++编译后在库中的名字与C语言的不同。假设某个函数的原型为： void foo（int x, int y）；该函数被C编译器编译后在库中的名字为_foo,而C++编译器则会产生像_foo_int_int之类的名字。C++提供了C连接交换指定符号extern"C"来解决名字匹配问题。

16. 将“引用”作为函数参数有哪些特点？
使用引用传递函数的参数，在内存中并没有还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，
使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。

17.结构与联合有和区别？
1. 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。 
2. 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。

18.头文件中的ifndef/define/endif 的作用？
防止该头文件被重复引用。

19. 比较C++中的4种类型转换方式？
C风格转换是“万能的转换”，但需要程序员把握转换的安全性，编译器无能为力；static_cast最接近于C风格转换，但在无关类指针转换时，编译器会报错，提升了安全性；dynamic_cast要求转换类型必须是指针或引用，且在下行转换时要求基类是多态的，如果发现下行转换不安全，dynamic_cast返回一个null指针，dynamic_cast总是认为void*之间的转换是安全的；reinterpret_cast可以对无关类指针进行转换，要求new_type是指针或引用，甚至可以直接将整型值转成指针，这种转换是底层的，有较强的平台依赖性，可移植性差；const_cast可以将常量转成非常量，但不会破坏原常量的const属性，只是返回一个去掉const的变量。

20.placement new 是重载operator new 的一个标准、全局的版本，它不能够被自定义的版本代替（不像普通版本的operator new和operator delete能够被替换）。placement new主要适用于：在对时间要求非常高的应用程序中，因为这些程序分配的时间是确定的；长时间运行而不被打断的程序；以及执行一个垃圾收集器.


21.默认参数在哪指定？函数声明还是定义？

编译器禁止声明和定义同时定义缺省参数值。缺省参数可以在定义中，也可以在声明中，定义时定义缺省参数值通常用户是看不见的，应避免。



22.怎么让struct不对齐

#pragma pack(1)，一字节对齐



23.多个文件中non-local static对象初始化顺序，怎么以指定顺序初始化

不确定的，c++没有规定

将每个非局部静态对象都移动到自己的函数中，并声明为静态的。并让这些函数返回这个静态对象的引用, 然后按照自己期望的对象初始化顺序来调用这些函数.



24.struct 和 class 的区别

struct 的成员默认是公有的，而类的成员默认是私有的。struct 和 class 在其他方面是功能相当的。



25. do...while(0)

消除goto语句

宏定义中的do...while(0) 

#define SAFE_DELETE(p) do{ delete p; p = NULL} while(0)
假设这里去掉do...while(0),
#define SAFE_DELETE(p) delete p; p = NULL;
那么以下代码：
if(NULL != p)

    SAFE_DELETE(p)
else

    dosometing();
就有两个问题，
1) 因为if分支后有两个语句，else分支没有对应的if，编译失败
2) 假设没有else, SAFE_DELETE中的第二个语句无论if测试是否通过，会永远执行。
你可能发现，为了避免这两个问题，我不一定要用这个令人费解的do...while,  我直接用{}括起来就可以了
#define SAFE_DELETE(p) { delete p; p = NULL;}
的确，这样的话上面的问题是不存在了，但是我想对于C++程序员来讲，在每个语句后面加分号是一种约定俗成的习惯，这样的话，以下代码:
if(NULL != p)

     SAFE_DELETE(p);
else

    dosometing(); 
其else分支就无法通过编译了（原因同上），所以采用do...while(0)是做好的选择了。



26.简述数组与指针的区别？

数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。



27.如何打印出当前源文件的文件名以及源文件的当前行号？

cout << __FILE__ ;

cout << __LINE__ ;



28.如何判断一段程序是由C 编译程序还是由C++编译程序编译的？

#ifdef __cplusplus
　　cout<<"c++";
#else
　　cout<<"c";
#endif

C



29.不用sizeof的功能来计算int型数据的字节数


int my_sizeof(int a)
{
      return ((char*)（&a+1）-(char*)&a)
}


30.sizeof是操作符，不是函数。

sizeof不能求得void类型的长度。

sizeof能求得void类型的指针的长度。

31.头文件的作用是什么?
一，通过头文件来调用库功能。向用户提供头文件和二进制的库，用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。
二,头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。

32.临时对象：辅助一个表达式的计算 a + b + c ，或者间接构造的实参，函数返回非引用的时候，都可能产生临时对象，临时对象生命周期，是单个语句，是右值。临时对象的开销比局部对象小些。

33.用一个宏定义FIND求一个结构体struc中某个变量相对struc的偏移量
  #define FIND(struc, e)  (size_t)&( ((struc*)0)->e )
其中（struc*）0表示将常量0转化为struc*类型指针所指向的地址。&( ((struc*)0)->e )表示取结构体指针（struc*）0的成员e的地址，因为该结构体的首地址为0，所以其实就是得到了成员e距离结构体首地址的偏移量，（size_t）是一种数据类型，为了便于不同系统之间的移植，最好定义为一种无符号型数据，一般为unsigned int

34. i++ 相比 ++i 哪个更高效？为什么？
（1)＋＋i 比 i++效率高。
  (2)i＋＋要多调用一次类的构造和析够函数

35.inline
a. inline只是一种建议，建议编译器将指定的函数在被调用点展开，因此编译器是可以忽略inline的（即不展开）
b. inline以代码膨胀（复制）为代价，省去了函数调用的开销，从而提高函数的执行效率
c. 每一处inline函数的调用都要复制代码，这将使得程序的总代码量增大，消耗更多的内存空间
d. inline必须与函数定义放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用
e. 定义在类声明之中的成员函数将自动地成为内联函数

36.explicit
禁止单参数构造函数被用于隐式类型转换

37.在声明赋值语句中，变量先声明，然后赋值
int i = 1;
int main() {
     int i = i;     //这里声明的i 覆盖了全局变量的i，之后的赋值就是局部变量的i 给自己赋值，因而其值是未定义的
     return 0;
}

38.从右到左压参数
int main() {
     int i = 1;
     printf("%d, %d\n", i, ++i);     //VS2010输出2, 2
}
虽然压参数的顺序是固定的，但计算顺序是编译器相关的，因此最后的结果与编译器相关。

40.何时需要预编译：
不经常改动的大型代码体。

程序由多个模块组成，所有模块都使用一组标准的包含文件和相同的编译选项。在这种情况下，可以将所有包含文件预编译为一个预编译头。

#pragma hdrstop表示预编译头文件到此为止



41.如何引用一个已经定义过的全局变量？

可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变理，假定你将那个变写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错



42.用什么函数开启新进程、线程。

线程：CreateThread/AfxBeginThread等

进程：CreateProcess等



43.SendMessage和PostMessage有什么区别

SendMessage是阻塞的，等消息被处理后，代码才能走到SendMessage的下一行。PostMessage是非阻塞的，不管消息是否已被处理，代码马上走到PostMessage的下一行。



44.处理器标识#error的目的是什么？

编译时输出一条错误信息，并中止编译。



45.strcpy()容易引起缓冲区溢出问题，请问有什么函数可以替代以减少风险，为什么?

strncpy

原型：extern char *strncpy(char *dest, char *src, int n);    
功能：把src所指由NULL结束的字符串的前n个字节复制到dest所指的数组中。    
说明：如果src的前n个字节不含NULL字符，则结果不会以NULL字符结束。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节。        
src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。 


46.简述strcpy、sprintf 与memcpy 的区别 

（1）操作对象不同，strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型， 目的操作对象是字符串，memcpy 的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。 

（2）执行效率不同，memcpy 最高，strcpy 次之，sprintf 的效率最低。 

（3）实现功能不同，strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。 



47.windows消息系统由哪几部分构成？

1. 消息队列：操作系统负责为进程维护一个消息队列，程序运行时不断从该消息队列中获取消息、处理消息；

2. 消息循环：应用程序通过消息循环不断获取消息、处理消息。

3. 消息处理：消息循环负责将消息派发到相关的窗口上使用关联的窗口过程函数进行处理。



48.什么是消息映射？

消息映射就是让程序员指定MFC类处理某个消息。然后由程序员完成对该处理函数的编写，以实现消息处理功能。



49.创建一个窗口的步骤是？

填充一个窗口类结构->注册这个窗口类->然后再创建窗口->显示窗口->更新窗口。



50.windows消息分为几类？并对各类做简单描述。

1.窗口消息：与窗口相关的消息，除WM_COMMAND之外的所有以WM_开头的消息；

2.命令消息；用于处理用户请求，以WM_COMMAND表示的消息；

3.控件通知消息：统一由WM_NOTIFT表示，

4.用户自定义消息。



51. 如何自定义消息？

使用WM_USER 和WM_APP两个宏来自定义消息，



52.MFC中，大部分类是从哪个类继承而来?

CObject



53.MFC中CString是类型安全类么？

不是，其它数据类型转换到CString可以使用CString的成员函数Format来转换



54.memset ,memcpy ,strcpy的区别

memset 把buffer所指内存区域的前count个字节设置成字符c。 

memcpy用来做内存拷贝，你可以拿它拷贝任何数据类型的对象，可以指定拷贝的数据长度；

strcpy就只能拷贝字符串了，它遇到'\0'就结束拷贝


55.char c = '\72'; 中的\72代表一个字符，72是八进制数，代表ASCII码字符“:”。

56.sizeof不是函数而是运算符，所以在计算变量所占用空间大小时，括号是可以省略的，但在计算类型大小时括号则不能省略，比如int i = 0; 则sizeof int是错误的。

57.如何将一个小数分解成整数部分和小数部分？ 利用头文件中的库函数modf
int main ()
{
  double param, fractpart, intpart;
  param = 3.14159265;
  fractpart = modf (param , &intpart);
  printf ("%f = %f + %f \n", param, intpart, fractpart);
  return 0;
}

58.可作为函数重载判断依据的有：参数个数、参数类型、const修饰符； 不可以作为重载判断依据的有：返回类型。
对于值传递，参数传递是通过复制实参创建一个临时变量传递进函数的，函数内只能改变临时变量，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是在引用或指针传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。
1.const重载主要是通过能否对传入的参数进行修改为判断的。

2.const参数重载和const函数重载机制都是一样的，因为对于const 函数重载可看做是对隐含的指针this的参数重载。

3.重载是在编译阶段已经完成，对于汇编和链接来说透明的。



59.C的结构体和C++结构体的区别
（1）C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。所以C的结构体是没有构造函数、析构函数、和this指针的。 
（2）C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。 
（3）C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。

60.在C++中，如果构造函数中调用了其它重载的构造函数，它将不会执行其它构造函数的初始化列表部分代码，而是执行函数体代码，

61.变量的声明和定义区别 
为变量分配地址和存储空间的称为定义，不分配地址的称为声明。一个变量可以在多个地方声明， 但是只在一个地方定义。加入extern 修饰的是变量的声明，说明此变量将在文件以外或在文件后面部分 定义。 

62.sizeof 和strlen 的区别 
sizeof 是一个操作符，strlen 是库函数。 
sizeof 的参数可以是数据的类型，也可以是变量，而strlen 只能以结尾为‘\0‘的字符串作参数。 
编译器在编译时就计算出了sizeof  的结果。而strlen在运行时计算出来。sizeof 计算的是数据类型占内存的大小，而strlen计算的是字符串实际的长度。 
数组做sizeof 的参数不退化，传递给strlen 就退化为指针了。 

63.链表和数组有什么区别 
（1）存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间， 长度可变，每个结点要保存相邻结点指针。 
（2）数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点， 效率低。 
（3）数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。 
（4）越界问题：链表不存在越界问题，数组有越界问题。 
数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。 

64.typedef 和define 有什么区别 
（1）用法不同：typedef  用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义常量，使用频繁的宏。 
（2）执行时间不同：typedef  是编译过程的一部分，有类型检查的功能。define 是预编译的部分，只是简单的进行字符串的替换，不进行类型的检查。 
（3）作用域不同：typedef 有作用域限定。define  不受作用域约束，只要是在define  声明后的引用 都是正确的。 
（4）对指针的操作不同：typedef 和define 定义的指针时有很大的区别。 
    #define PINT int *
    typedef int * pint;

    int a =3;
    int b =5;
    const pint p1=&a; //相当于 int * const p1;  p1 不可以更改但指向的内容能被修改
    *p1=1;
    p1=&b;  //error
    const PINT p2 =&a;//相当于 const int * p2;  p2 可以被修改但指向的内容不可以修改
    p2=&b;
    *p2=1;  //error
typedef 定义是语句，因为句尾要加上分号。而define 不是语句，千万不能在句尾加分号。 

63.extern 有什么作用 
 extern 标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块 中寻找其定义。 

64.“野指针”产生原因及解决办法如下
（1）指针变量声明时没有被初始化。解决办法：指针声明时初始化，可以是具体的地址值，也可让它指向NULL 。 
（2）指针p被 free 或者delete之后，没有置为NULL 。解决办法：指针指向的内存空间被释放后指针应该指向NULL 。 
（3）指针操作超越了变量的作用范围。解决办法：在变量的作用域结束前释放掉变量的地址空间并且让指针指向NULL 。 

65.全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？
可以，以static形式来声明全局变量
#ifndef/#pragma once防止重复包含
可以在不同的C文件中声明同名的全局变量，前提是其中只能有一个C文件中对此变量赋初值，此时连接不会出错.

66.C和C++能否相互调用
可以，都是通过extern c
C调用C++，使用extern "C"则是告诉编译器依照C的方式来编译封装接口，当然接口函数里面的C++语法还是按C++方式编译。
而C++调用C，extern "C" 的作用是：让C++连接器找调用函数的符号时采用C的方式

67.重载可以区分int和long吗
可以，如果给一个整形常量，后面要加L或l时，编译器才知道是long，否则默认为int

68.如何做到局部static第一次经过的时候初始化，再次经过不再初始化
static变量的前面或者后面有一个字节标识是否初始化过

69. ebp  esp
在堆栈中变量分布是从高地址到低地址分布，EBP是指向栈底的指针，在过程调用中不变，又称为帧指针。ESP指向栈顶，程序执行时移动，ESP减小分配空间，ESP增大释放空间，ESP又称为栈指针。
下面来逐步分析函数的调用过程

1.函数main执行，main各个参数从右向左逐步压入栈中，最后压入返回地址

2.函数调用时，通过跳转指令进入函数后，函数地址入栈后，EBP入栈，然后把当前ESP的值给EBP
3.调用执行函数完毕，局部变量一次出栈，EBP恢复原值，返回地址出栈，找到原执行地址，参数依次出栈，函数调用执行完毕
<img src="images/cplus_1.jpg" alt="jvm物理结构" />

70.C 不确定参数个数的函数的实现，如果参数类型不同呢，比如包括int,double
int sum(int num,...){
	int ret=0;
	for(int i=1;i<=num;i++)
		ret+=*(&num+i);
	return ret;
}

71.如何希望函数只被调用一次  
static bool flag = false;
if(!flag){
    callee();
    flag = true;
}

假设callee的返回类型时int：

static int dummy = callee(); 

如果callee的返回类型是void:
static bool dummy = (callee(), true);

72.不用sizeof判断机器位数  
#include <stdio.h>  
int main(int argc, char* argv[]) {  
    unsigned int a = ~0;  
    int i = 1;  
    while ( (a = a >> 1) )  
        i++;  
    printf("%d byte %d bits\n", i / 8, i);  
    return 0;  
}  

73..涉及链表节点的O(1)存取，要考虑传入的参数是否是指针，指针直接next、prev就可以了

74.Catalan数
令h(0)=1,h(1)=1，Catalan数递归式：h(n)= h(0)*h(n-1) + h(1)*h(n-2) + 其他 - 562963269 - 562963269的博客 + h(n-1)h(0) (n>=2)
该递推关系的解为：h(n)=C(2n,n)/(n + 1) (n=1,2,3,其他 - 562963269 - 562963269的博客)
前几项为 : 1, 1, 2, 5, 14, 42, 132, 429
典型的四类应用：（实质上都一样，是递归等式的应用，就看你能不能分解问题写出递归式了）
1.括号化问题。
　　矩阵链乘： P=a1×a2×a3×……×an，依据乘法结合律，不改变其顺序，只用括号表示成对的乘积，试问有几种括号化的方案？(h(n-1)种)

2.出栈次序问题。
　　一个栈(无穷大)的进栈序列为1,2,3,..n,有多少个不同的出栈序列?(h(n)种)
　　有2n个人排成一行进入剧场。入场费5元。其中有n个人有一张5元钞票，另外n人只有10元钞票，剧院无其它钞票，问有多少方法使得只要有10元的人买票，售票处就有5元的钞票找零？(h(n)种)
     一位大城市的律师在她住所以北n个街区和以东n个街区处工作。每天她走2n个街区去上班。如果她从不穿越（但可以碰到）从家到办公室的对角线，那么有多少条可能的道路？

3.将多边行划分为三角形问题。
　　将一个凸多边形区域分成三角形区域的方法数?
　　在圆上选择2n个点,将这些点成对连接起来使得所得到的n条线段不相交的方法数?(h(n)种)

4.给定节点组成二叉树的问题。
　　给定N个节点，能构成多少种形状不同的二叉树？(先去一个点作为顶点,然后左边依次可以取0至N-1个相对应的,右边是N-1到0个,两两配对相乘,就是h(0)*h(n-1) + h(2)*h(n-2) + 其他 - 562963269 - 562963269的博客 + h(n-1)h(0)=h(n))

75.对左值和右值的一个最常见的误解是：等号左边的就是左值，等号右边的就是右值。左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象。一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。

76.如果确定某个值是一个非常量右值（或者是一个以后不会再使用的左值），则我们在进行临时对象的拷贝时，可以不用拷贝实际的数据，而只是“窃取”指向实际数据的指针（类似于STL中的auto_ptr，会转移所有权）。C++ 11中引入的右值引用标识一个非常量右值。C++ 11中用&表示左值引用，用&&表示右值引用。