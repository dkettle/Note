c++面向对象
=
1.什么是多态？多态可以用来做什么？

系统能够在运行时，能够根据其类型确定调用哪个重载的成员函数的能力，称为多态性，利用继承和虚函数实现

隐藏实现细节，使得代码能够模块化；扩展代码模块，实现代码重用；

接口重用：为了类在继承和派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。

 

2.虚函数的实现机制？一个空的对象（包含虚函数的类的对象）占几个字节？（32位和64位机器分别是多少？）

虚函数表，虚函数指针。4，8.


3.什么是抽象类？抽象类的作用是什么？

抽象类（abstract class）的主要目的是为它的子类定义公共接口。一个抽象类将它的部分或全部操作的实现延迟到子类中，因此，一个抽象类不能被实例化。


4.多态类中的虚函数表是Compile-Time，还是Run-Time时建立的
虚拟函数表是在编译期就建立了,虚拟函数表指针是在运行期,也就是构造函数被调用时进行初始化.


5.什么是封装？C++中是如何实现的？
通过特性和行为的组合来创建新数据类型让接口与具体实现相隔离。C++中是通过类来实现的， 为了尽量避免某个模块的行为干扰同一系统中的其它模块，应该让模块仅仅公开必须让外界知道的接口。


6.什么是RTTI?
在只有一个指向基类的指针或引用时确定一个对象的准确类型。


7.什么是深浅拷贝？
浅拷贝是创建了一个对象用一个现成的对象初始化它的时候只是复制了成员（简单赋值）而没有拷贝分配给成员的资源（如给其指针变量成员分配了动态内存）； 深拷贝是当一个对象创建时，如果分配了资源，就需要定义自己的拷贝构造函数，使之不但拷贝成员也拷贝分配给它的资源。

 

8.面向对象程序设计的优点？

开发时间短， 效率高， 可靠性高。面向对象编程的编码具有高可重用性，可以在应用程序中大量采用成熟的类库（如STL），从而虽短了开发时间，软件易于维护和升级。

 

9.继承和组合的区别？

组合和继承的比较继承和组合都是代码复用的有效方法。组合是将其他类的对象作为成员使用，继承是子类可以使用父类的成员方法。若在逻辑上B 是A 的“一种”（a kind of ），则继承。若在逻辑上A 是B 的“一部分”（a part of），则组合。

 

10.面向对象的三个基本特征，并简单叙述之？

1. 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected,public)

2. 继承：广义的继承有三种实现形式：实现继承（指使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法，实现滞后到子类实现）。前两种（类继承）和后一种（对象组合=>接口继承以及纯虚函数）构成了功能复用的两种方式。

3. 多态：系统能够在运行时，能够根据其类型确定调用哪个重载的成员函数的能力，称为多态性。

 

11.C++是不是类型安全的？

不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。

 

12.拷贝构造函数作用及用途

对象赋值、对象作为函数参数、对象作为函数返回值

 

13.什么时候需要自定义拷贝构造函数

默认的构造函数是浅复制,当类中的数据成员需要动态分配存储空间时，不可以依赖默认的复制构造函数。或者在创建新对象时必须做一些特定工作，比如打开文件。

 

14.C++模板，特化，偏特化

C++的模板提供了对逻辑结构相同的数据对象通用行为的定义。这些模板运算对象的类型不是实际的数据类型，而是一种参数化的类型。

有时为了需要，针对特定的类型，需要对模板进行特化，也就是所谓的特殊处理。

template <class T>
class Compare
{
public:
     bool IsEqual(constT& arg, const T& arg1);
};
 
// 已经不具有template的意思了，已经明确为float了
template <>
class Compare<float>
{
public:
     bool IsEqual(constfloat& arg, const float& arg1);
};

偏特化是指提供另一份template定义式，而其本身仍为templatized；也就是说，针对template参数更进一步的条件限制所设计出来的一个特化版本。

// 一般化设计
template <class T, class T1>
class TestClass
{
public:
     TestClass()
     {
         cout<<"T, T1"<<endl;
     }
};
 
// 针对普通指针的偏特化设计
template <class T, class T1>
class TestClass<T*, T1*>
{
public:
     TestClass()
     {
         cout<<"T*, T1*"<<endl;
     }
};

 

15.c++类内存模型，为什么要多个虚表指针，为什么要多个虚基类指针

用不同的基类指针访问时对应的虚函数表是不一样的，要多个虚表指针，其中第一个基类和派生类的虚函数表合并在一起

虚基类相对于不同基类的偏移是不一样的，通过不同的基类指针访问时需要不同的偏移，要多个虚基类指针

 

16.有哪几种情况只能用intializationlist 而不能用assignment?

当类中含有const、reference 成员变量；基类无默认构造函数，类成员无默认构造函数

 

17.main 函数执行以前和以后，还会执行什么代码？

初始化全局对象和static对象

初始化栈指针

将main函数的参数，argc，argv等传递给main函数

全局对象的析构函数会在main函数之后执行； 使用_onexit/atexit注册的函数可以在main之后执行

 

18.当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。

1;如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。

 

19.类成员函数的重载、覆盖和隐藏区别？

a.成员函数被重载的特征：
（1）相同的范围（在同一个类中）；
（2）函数名字相同；
（3）参数不同；
（4）virtual 关键字可有可无。
b.覆盖是指派生类函数覆盖基类函数，特征是：
（1）不同的范围（分别位于派生类与基类）；
（2）函数名字相同；
（3）参数相同；
（4）基类函数必须有virtual 关键字。
c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）

 

20.C++中哪些函数不能被声明为虚函数？

普通函数（非成员函数），构造函数，内联成员函数、静态成员函数、友元函数。

 

21.论述C++类继承的优缺点

一，优点：类继承是在编译时刻静态定义的，可以直接使用，类继承可以较方便的改变从父类继承的实现

二，缺点：1，因为继承在编译时刻就定义了，所以无法在运行时刻改变从父类继承的实现

2，父类通常至少定义了子类的部分行为，父类的任何改变都可能影响到子类的行为

3，如果继承下来的实现不适合解决新的问题，则父类必须重写或被其他更适合的类替换

这种依赖关系先限制了灵活性并最终限制了复用性

 

22.运算符重载的三种方式和不允许重载的5个运算符

(1)普通函数，友元函数，类成员函数

（2）.*（成员指针访问运算符）   

   ：：（域运算符） 

  sizeof 长度运算符   

  ？：条件运算符   

  .(成员访问运算符)

 

23.在头文件中进行类的声明，在对应的实现文件中进行类的定义, 有什么意义？

可以提高编译效率，因为分开的话只需要编译一次生成对应的.obj文件后，再次应用该类的地方，这个类就不会被再次编译，从而大大提高了效率。

 

24.流运算符为什么不能通过类的成员函数重载？一般怎么解决？

通过类的成员函数重载必须运算符的第一个参数是类自己，而对流运算的重载要求第一个参数是流对象。一般通过友元来解决。

 

25.友元关系有什么特性？

单向的，非传递的，不能继承的。

 

26.构造函数和析构函数是否可以被重载,为什么?

构造函数可以被重载，析构函数不可以被重载。因为构造函数可以有多个且可以带参数，而析构函数只能有一个，且不能带参数。

 

27.如何定义和实现一个类的成员函数为回调函数？

回调函数就是一个通过函数指针调用的函数。如果你把函数的地址作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。将一个成员函数作为回调函数时会因为隐含的this指针使得函数参数个数不匹配。通过采用以下两种典型技术可以解决在C++中使用回调函数所遇到的问题。  

    1).   不使用成员函数，为了访问类的成员变量，可以使用友元操作符(friend)，在C++中将该函数说明为类的友元即可。   
    2).   使用静态成员函数。静态成员函数具有两大特点：其一，可以在没有类实例的情况下使用；其二，只能访问静态成员变量和静态成员函数，不能访问非静态成员变量和非静态成员函数。使用类成员函数作为回调函数的目的是为了访问所有的成员变量和成员函数，如果做不到这一点将不具有实际意义。可以使用回调函数的一个参数来传递this指针，从而实现数据成员共享。

 

28.怎样消除多重继承中的二义性？

1．成员限定符

2．虚基类

 

29.函数模板与类模板有什么区别？

函数模板的实例化是由编译程序自动完成的，而类模板的实例化 必须由程序员在程序中显式地指定。

 

30.用C++设计一个不能被继承的类 

      template <typename T> class A 

      { 

           friend T; 

      private: 

           A() {} 

           ~A() {} 

      }; 

      class B : virtual public A<B> 

      { 

      public: 

           B() {} 

           ~B() {} 

      }; 

      class C : virtual public B 

      { 

      public: 

           C() {} 

           ~C() {} 

      }; 

      void main( void ) 

      { 

           B b; 

           //C c; 

           return; 

      } 

 

31.访问基类的私有虚函数 

      #include <iostream.h> 

      class A 

      { 

             virtual void g() 

             { 

                   cout << "A::g" << endl; 

             } 

       private: 

             virtual void f() 

             { 

                   cout << "A::f" << endl; 

             } 

      }; 

      class B : public A 

      { 

             void g() 

             { 

                   cout << "B::g" << endl; 

             } 

             virtual void h() 

             { 

                   cout << "B::h" << endl; 

             } 

      }; 

      typedef void( *Fun )( void ); 

      void main() 

      { 

             B b; 

         Fun pFun; 

             for(int i = 0 ; i < 3; i++) 

             { 

                   pFun = ( Fun )*( ( int* ) * ( int* )( &b ) + i ); 

                   pFun(); 

             } 

      } 

输出结果： 

       B::g 

       A::f 

       B::h 

 

32.this指针是什么时候创建的？

this在成员函数的开始执行前构造，在成员的执行结束后清除。传给函数的参数类型是A* const this,若是const成员函数则为const A* const this

但是如果class或者struct里面没有方法的话，它们是没有构造函数的，只能当做C的struct使用。采用 TYPE xx的方式定义的话，在栈里分配内存，这时候this指针的值就是这块内存的地址。采用new的方式 创建对象的话，在堆里分配内存，new操作符通过eax返回分配 的地址，然后设置给指针变量。之后去调用构造函数（如果有构造函数的话），这时将这个内存块的地址传给ecx，之后构造函数里面怎么处理请 看上面的回答。




33.this指针存放在何处？堆、栈、全局变量，还是其他？

this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。

 

34.this指针是如何传递类中的函数的？绑定？还是在函数参数的首参数就是this指针？那么，this指针 又是如何找到“类实例后函数的”？

大多数编译器通过ecx寄存器传递this指针。事实上，这也是一个潜规则。一般来说，不同编译器都会遵从一致的传参规则，否则不同编译器产生的obj就无法匹配了。在call之前，编译器会把对应的对象地址放到eax中。this是通过函数参数的首参来传递的。this指针在调用之前生成，至于“类实例后函数”，没有这个说法。类在实例化时，只分配类中的变量空间，并没有为函数分配空间。自从类的函数定义完成后，它就在那儿。

 

35.this指针是如何访问类中的变量的？

和通过struct指针来访问struct中的变量相同，起始地址+offset

 

36.我们只有获得一个对象后，才能通过对象使用this指针。如果我们知道一个对象this指针的位置，可以直接使用吗？

this指针只有在成员函数中才有定义。因此，你获得一个对象后，也不能通过对象使用this指针。所以，我们无法知道一个对象的this指针的位置（只有在成员函数里才有this指针的位置）。当然，在成员函数里，你是可以知道this指针的位置的（可以通过&this获得），也可以直接使用它。

 

37.每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？

普通的类函数（成员函数，静态函数）不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。如果编译器能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。

 

38.static成员函数不能声明为const

const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall
而类中的static函数本质上是全局函数，调用规约是__cdecl或__stdcall,不能用const来修饰它

static const return_type func()这样没问题，表示返回值是const类型

 

39.防止内存泄漏的办法

良好的编码习惯

智能指针   

重载  new和 delete，实现垃圾回收。

将基类的析构函数定义成虚函数

使用new,delete要采用相同的形式