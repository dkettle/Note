JAVA编程思想
=

第七章 复用类
-

1.每一个非基本类型的对象都有一个toString()方法， 当编译器需要一个String而你只有一个对象时，该方法便会被调用。

2.类中域为基本类型时能够自动被初始化为0， 但对象引用会被初始化为null，而且如果你试图为它们调用任何方法，都会得到一个异常－－运行时错误.

3.到底是该用组合还是继承，一个最清晰的判断方法：如果必须向上转型，则继承是必须的，否则应当好好考虑是否需要继承。

4.类的代码在首次使用时才加载。这通常是指加载发生于创建类的第一个对象之时，但是当访问static域或方法时，也会发生加载。

5.所有static对象和代码段都会在加载时依程序中的顺序初始化。

6.构造器也是static方法，尽管没有显示地写出来，因此更准确滴讲，类是在其任何static成员被访问时加载的。

第八章 多态
-

1.Java中除了static方法和final方法(private方法属于final方法)之外，其他的方法都是后期绑定。

2.只有普通的方法调用可以是多态的，如果直接访问某个域，这个访问将在编译期解析。如果某个方法是静态的，她的行为就不具有静态性，静态方法是与类，而不是单个对象关联的。

3.与c++不同，java构造器中调用方法会动态绑定。编写构造器时一条有效的准则：用尽可能简单的方法使对象进入正常状态，尽量避免调用其它方法。在构造器内唯一能够安全调用的方法是基类中的final方法。

4.协变返回类型：在子类覆盖基类的方法中可以返回基类被覆盖方法返回类型的某种子类类型。

5.java中所有转型都会得到检查，以确保它的确是我们希望的那种类型，若不是则返回一个classcastexception。这种运行期间对类型进行检查的行为称为运行时类型识别（rtti）

第九章 接口
-

1.使用接口的原因：能够向上转型为多个基类型；防止客户端程序员创建该类的对象。如果要创建不带任何方法定义和成员变量的基类，那么应该选择接口而不是抽象类。

第十章 内部类
-

1. 	内部类拥有其外围类的所有元素的访问权。当某个外围类的对象创建了一个内部类对象时，内部类对象会秘密捕获一个外围类对象的引用。当你访问外围类的成员时，用那个引用来选择外围类的成员。在拥有外部类之前是不可能创建内部类对象的。

第十一章 持有对象
-
1.foreach可以用于数组和任何iterable，但是数组并不是iterable，不存在数组到iterable的自动转换。

2.容器不能持有基本类型，但自动包装机制会执行基本类型到容器中所持有的包装器类型之间的双向转换。

第十三章 字符串
-
1.toString方法中，如果想打印对象的内存地址，不该使用this，调用this会发生递归调用，而是应该调用super.toString()方法，即object.tostring()