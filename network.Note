计算机网络相关
=

1.TCP与UDP的区别？


TCP(传输控制协议)：TCP是一个面向连接的协议。从客户端到服务器可以建立一个连接， 然后数据通过这个连接进行传输。TCP协议具有以下特点：

可靠的。当你沿着一个TCP套接字发送消息，只要连接没有完全中断， 你就有把握它会到达目的地。如果数据包在传输过程中丢失了， 服务器将重新请求丢失的数据包。这意味着服务器将接收到完整而没有损坏的数据。

有序的。TCP数据包中包括序号和确认，所以未按照顺序收到的包可以被排序。 你不必为数据包的到达顺序而担心。

重量级的。当TCP字节流以错误的顺序到达，计算机将发出重新发送请求。 序列中已经发出的部分必须一起放回，这个需要一些工作量。

UDP(用户数据报协议)：UDP是无连接的协议。UDP以数据块的形式在网络中发送消息/数据包。 UDP协议的特点如下：

不可靠的。当你发送一个消息，你并不能确保它会到达。它有可能在传输中丢失。

无序的。当你发送出两个消息。你无法确保哪一个会先到达。

轻量的。不会考虑发送消息的顺序，没有连接跟踪，仅仅是发送出去，然后就不管它了。 这也意味着它非常快速，网卡和操作系统只需要做很少的工作来数据包中的数据。

<img src="images/net_1.jpg" alt="jvm物理结构" />


2.TCP建立连接需要经过几次握手？过程是怎样的？释放连接需要经过几次挥手？过程是怎样的？

建立连接协议（三次握手）
（1）客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的报文1。
（2） 服务器端回应客户端的，这是三次握手中的第2个报文，这个报文同时带ACK标志和SYN标志。因此它表示对刚才客户端SYN报文的回应；同时又标志SYN给客户端，询问客户端是否准备好进行数据通讯。
（3） 客户必须再次回应服务段一个ACK报文，这是报文段3。

当第三次握手失败时服务器并不会重传ack报文，而是直接发送RTS报文段，进入CLOSED状态。这样做是为了防止SYN洪泛攻击。

连接终止协议（四次握手）,由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
　（1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送（报文段4）。
　（2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。
　（3） 服务器关闭客户端的连接，发送一个FIN给客户端（报文段6）。
　（4） 客户段发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。


3.TCP状态转化图

<img src="images/net_2.png" alt="jvm物理结构" />

CLOSED: 表示初始状态。
LISTEN: 表示服务器端的某个SOCKET处于监听状态，可以接受连接了。
SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本 上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态 时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。
SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状 态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。
ESTABLISHED：表示连接已经建立了。
FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别 是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即 进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马 上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。
FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。
TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。
CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什 么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报 文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。
CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对 方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。
LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。




4.为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？

虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到 ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于 LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的 ACK报文。


5.为什么TCP叫做数据的“流”传输，而UDP叫做“报文”的传输？


面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。
 
面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。

6.GET和POST的区别？

1. get是从服务器上获取数据，post是向服务器传送数据。
2. get是把参数数据队列加到提交表单的action属性所指的url中，值和表单内各个字段一一对应，在url中可以看到。post是通过http post机制，将表单内各个字段与其内容放置在html header内一起传送到action属性所指的url地址。用户看不到这个过程。
3. 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。
4. get传送的数据量较小，不能大于2KB。post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。
5. get安全性非常低，post安全性较高。但是执行效率却比Post方法好。 

1、get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；
2、在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；

7.用什么命令查看域名对应的IP地址？
nslookup



8.心跳(保活)机制

当一个TCP的socket，客户端与服务端谁也不发送数据，会一直保持着连接。如果有一方异常掉线（例如死机、路由被破坏、防火墙切断连接等），另一端如果没有发送数据，永远也不可能知道。这对于一些服务型的程序来说，是灾难性的后果，将会导致服务端socket资源耗尽。为了保证连接的有效性、及时有效地检测到一方的非正常断开，保证连接的资源被有效的利用，我们就会需要一种保活的机制，通常有两种处理方式：1、利用TCP协议层实现的Keepalive；2、自己在应用层实现心跳包。

  两种方式的对比如下：

  1、TCP协议自带的保活功能, 使用起来简单, 减少了应用层代码的复杂度.更节省流量, 因为一般来说应用层的数据传输到协议层时都会被加上额外的包头包尾. 由TCP协议提供的检活, 其发的ACK包比应用层的心跳包耗费更少的流量。

  2、应用层心跳包相对与Keepalive更灵活，因为协议层的心跳只能提供最纯粹的检活功能, 但是应用层自己可以随意控制，甚至加入一些额外逻辑；应用层心跳包不依赖于协议，如若有一天不用TCP要改为UDP了，只需做少量改动甚至不用改动即可实现转换。

保活（keepalive）并不是TCP规范的一部分。理由：（1）在短暂的故障期间，它们可能引起一个良好连接被释放（2）消费了不必要的宽带，（3）在以数据包计费的互联网上它们（额外）花费金钱。



9.arp攻击

通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量使网络阻塞，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。



10.简述TCP协议在数据传输过程中收发双方是如何保证数据包的可靠性的

确认、序列号、超时重传

（1）为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；
（2）并为每个已发送的数据包启动一个超时定时器；
（3）如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;
（4）否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。
（5）接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可放在数据包中捎带过去。




对每个连接，T C P管理4个不同的定时器。

1) 重传定时器使用于当希望收到另一端的确认。

2) 坚持( p e r s i s t )定时器使窗口大小信息保持不断流动，即使另一端关闭了其接收窗口。

3) 保活( k e e p a l i v e )定时器可检测到一个空闲连接的另一端何时崩溃或重启。

4) 2MSL定时器测量一个连接处于T I M E _ WA I T状态的时间。



11.交换机怎么知道数据发往哪个端口

MAC地址表



12.包为什么会失序

包走的路径不一样，排队花的时间不一样等



13.windows平台下网络编程有哪几种网络编程模型？

有阻塞，select，基于窗体的事件模型，事件模型，重叠模型，完成端口模型。
除了阻塞模型外，其他都是非阻塞模型，其中效率最高的是完成端口模型，尤其在windows下服务器最合适了。
做客户端一般用事件模型了,select在window和类unix都可以使用。

14.解释一下，在你往浏览器中输入一个URL后都发生了什么
浏览器向DNS服务器查找输入URL对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISP DNS缓存，根域名服务器。

DNS服务器返回网站的IP地址。

浏览器根据IP地址与目标web服务器在80端口上建立TCP连接

浏览器获取请求页面的html代码。

浏览器在显示窗口内渲染HTML。

窗口关闭时，浏览器终止与服务器的连接。


15.比较IPv4和IPv6协议。
IPv4和IPv6是因特网协议，应用于网络层。IPv4是现在应用得最广泛的协议， 而IPv6是因特网的下一代协议。

IPv4是因特网协议的第4个版本，它使用32位寻址技术。IPv6是下一代因特网协议， 用的是128位寻址。

IPv4最多允许4,294,967,296个独立IP地址，而IPv6可以允许34, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000, 000个IP地址。 (34后面带36个0)

IPv4中，IP地址分为以下几类：A，B，C，D和E。 A，B，C是3类实际在网络中使用的IP地址。D类地址为组播保留。E类地址是保留地址， 意味着它们不应该在IP网络上使用。(除非是一些研究机构出于实验目的才会使用)

IPv6地址大致可分为3类：

单播地址。一个单播地址就是一个单一接口的标识符。 一个发送到单播地址的IPv6报文会被传送到该地址所标识的接口。
组播地址。组播地址就是一组接口的标识符，这些接口可能属于不同的节点。 一个发送到组播地址的IPv6报文会被传送到多个接口。
任播地址(任一广播地址)。任播地址是一组接口的标识符， 这些接口可能属于不同节点(这点和组播地址相同)。一个发送到任播地址的IPv6 报文会被传送到这组接口中的其中一个。
IPv4地址表示：239.255.255.255, 255.255.255.0

IPv6地址用分号“:”分成8段，用16进制表示。比如： 2001:cdba:0000:0000:0000:0000:3257:9652

由于人口数量的增加(对IP地址的需求增加)，IPv6的需求日益明显，它能带来以下好处：

增加地址空间

更高效的路由

降低管理要求

改善更换ISP的方法

更好的移动支持

多宿主

安全

作用域地址：本地链路，本地站点和全局地址空间


15.主机A是如何发送消息/包给主机B
当两台主机在同一网络上时，通过主机地址的二进制位识别其它主机。

当两台主机不在同一网络时，路由器通过网络掩码来识别网络并路由数据包。 每台主机可以通过网络主机地址来识别。

网络层负责进行路由决策。路由表存储路径信息及其对应的开销， 路由算法使用路由表来决定路由这些数据包的路径。

路由一般分为静态路由和动态路由。划分依据是： 路由表是固定的还是会根据当前网络状况而改变。



16.为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一 个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未 必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文 和FIN报文多数情况下都是分开发送的。



17. TCP滑动窗口

TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流量控制。同时滑动窗口机制还体现了TCP面向字节流的设计思路。

1）对于TCP会话的发送方，任何时候在其发送缓存内的数据都可以分为4类，“已经发送并得到对端ACK的”，“已经发送但还未收到对端ACK的”，“未发送但对端允许发送的”，“未发送且对端不允许发送”。“已经发送但还未收到对端ACK的”和“未发送但对端允许发送的”这两部分数据称之为发送窗口。

2）对于TCP的接收方，在某一时刻在它的接收缓存内存在3种。“已接收”，“未接收准备接收”，“未接收并未准备接收”（由于ACK直接由TCP协议栈回复，默认无应用延迟，不存在“已接收未回复ACK”）。其中“未接收准备接收”称之为接收窗口。



18.流量控制

接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制。主要的方式就是返回的ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送：

<img src="images/net_3.png" alt="jvm物理结构" />

如果B已经告诉A自己的缓冲区已满，于是A停止发送数据；等待一段时间后，B的缓冲区出现了富余，于是给A发送报文告诉A我的rwnd大小为400，但是这个报文不幸丢失了，于是就出现A等待B的通知||B等待A发送数据的死锁状态。为了处理这种问题，TCP引入了持续计时器（Persistence timer），当A收到对方的零窗口通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待。



单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，增加了网络中的许多不必要的报文（为了一个字节数据而添加的40字节头部），所以尽可能一次多发送几个字节，或者窗口空余较多的时候通知发送方一次发送多个字节。对于前者我们广泛使用Nagle算法，即：

*1. 若发送应用进程要把发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来；
*2. 当发送方收到第一个字节的确认后（也得到了网络情况和对方的接收窗口大小），再把缓冲区的剩余字节组成合适大小的报文发送出去；
*3. 当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；
  对于后者我们往往的做法是让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。



19.拥塞控制

1. 慢开始、拥塞控制

-1. 发送方维持一个叫做“拥塞窗口”的变量，该变量和接收端口共同决定了发送者的发送窗口；
-2. 当主机开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个1字节的试探报文；
-3. 当收到第一个字节的数据的确认后，就发送2个字节的报文；
-4. 若再次收到2个字节的确认，则发送4个字节，依次递增2的指数级；
-5. 最后会达到一个提前预设的“慢开始门限”，比如24，即一次发送了24个分组，此时遵循下面的条件判定：
*1. cwnd < ssthresh， 继续使用慢开始算法；
*2. cwnd > ssthresh，停止使用慢开始算法，改用拥塞避免算法；
*3. cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法；
-6. 所谓拥塞避免算法就是：每经过一个往返时间RTT就把发送方的拥塞窗口+1，即让拥塞窗口缓慢地增大，按照线性规律增长；
-7. 当出现网络拥塞，比如丢包时，将慢开始门限设为原先的一半，然后将cwnd设为1，执行慢开始算法

2. 快重传、快恢复

-1. 接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求；
-2. 一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包；
-3. 此时发送方开始执行“快恢复”算法：
*1. 慢开始门限减半；
*2. cwnd设为慢开始门限减半后的数值；
*3. 执行拥塞避免算法（高起点，线性增长）；



20.tcp中的粘包的处理方法

TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

出现粘包既可能由发送方造成，也可能由接收方造成。发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据。若连续几次发送的数据都很少，通常TCP会把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据。
接收方引起的粘包是由于接收方用户进程不及时接收数据，从而导致粘包现象。这是因为接收方先把收到的数据放在系统接收缓冲区，用户进程从该缓冲区取数据，若下一包数据到达时前一包数据尚未被用户进程取走，则下一包数据放到系统接收缓冲区时就接到前一包数据之后，而用户进程根据预先设定的缓冲区大小从系统接收缓冲区取数据，这样就一次取到了多包数据。

解决：自己构建发出包的格式

21.winsock建立连接的主要实现步骤?
服务器端：socket()建立套接字，绑定（bind）并监听（listen），用accept（）等待客户端连接, accept（）发现有客户端连接，建立一个新的套接字，自身重新开始等待连接。该新产生的套接字使用send()和recv（）写读数据，直至数据交换完毕，closesocket()关闭套接字。

客户端：socket()建立套接字，连接（connect）服务器，连接上后使用send()和recv（），在套接字上写读数据，直至数据交换完毕，closesocket()关闭套接字。


22.tcp三次握手的过程，connect,accept发生在三次握手哪个阶段？
第一次握手：客户端发送syn包(syn=j)到服务器，connect阻塞。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个ASK包（ask=k），connect返回，accept阻塞。
第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，accept返回。

23.用UDP协议通讯时怎样得知目标机是否获得了数据包
可以在每个数据包中插入一个唯一的ID，比如timestamp或者递增的int。发送方在发送数据时将此ID和发送时间记录在本地。接收方在收到数据后将ID再发给发送方作为回应。发送方如果收到回应，则知道接收方已经收到相应的数据包；如果在指定时间内没有收到回应，则数据包可能丢失，需要重复上面的过程重新发送一次，直到确定对方收到。

24.ARP解析的全过程
第一步：应用产生数据，这里用FTP协议为例，在FTP协议中定位了目的IP。

第二步：封装的过程如下：

应用层：需要FTP的控制信息，包括用户名、密码等;
传输层：目的端口号为21，源为随机端口号;
网络层：目的IP为172.16.1.200，源IP为172.16.1.1;
数据链路层：因为不知道目的IP 172.16.1.200对应的MAC，所以目的IP到目的MAC的封装映射失败;
三层到二层的封装失败，由于二层是以太网，ARP的工作机制便会产生ARP Request去解析目的MAC，此时，源MAC为数据发起者的MAC，目的MAC地址为FFFF:FFFF:FFFF（代表所有MAC）

第三步：ARP Request到达本网段中的所有设备上，所有设备都可以拆掉二层的封装，然后解读ARP数据包中需要解析的目的IP。

第四步：目的IP不正确的设备直接忽略这个ARP请求包，目的IP正确的设备，会产生一个ARP Reply去回应这个ARP Request。

第五步：数据的发起者接到ARP Reply后，将目的IP与目的MAC的对应关系添加到自己的ARP表中。

第六步：之前未完成二层封装的FTP数据，这时重新开始封装二层头部，此时，正确的目的MAC就被封装到了整个数据帧中。只有完成了整个TCP/IP协议栈封装的数据帧，才能正常的从主机上发出去。



25TCP已经使用一些机制可靠的发送过去，为何传输层不向上提供一个“ACK”，还要让开发者从应用层发送一个“ACK",这样TCP不是更慢了吗?UDP的Send recv又怎么判断对方是否成功接收?
就是要应用层发送一个确认。TCP 的 ACK 表示对方的协议栈已经受到了你发的数据，不代表对方的应用程序收到了你发的消息。对方的应用程序可能死锁或者阻塞，不会去调用 recv，那么你发的数据就堆积在对方协议栈的接收缓冲区里了。
UDP只管发送，其他啥都不管。所以UDP“通常意义”上会比TCP快，尤其在稳定的网络里头。但代价就是，要确保数据完整性准确性，就只能通过更多代码和逻辑去处理了。广泛用于稳定的内网传输以及允许丢失数据的实时通信。

26.建立socket连接后开始传送数据，此时网络断开了，数据传送了一部分，如何用程序控制网络修复后的数据继续传送？
1）写临时文件，当网络断开时，在发送端，将没发送完的数据写入临时文件（包括操作命令）
2）客户端也写临时文件。
3）在客户端再次连接时，就继续上次的发送
肯定要重新做connect，在网络断开时，如果这时发送数据，TCP在发送超时后会将该socket关闭，这样原先的socket就不可用了。只有在超时之前恢复连接，才可以继续使用原先的socket。如果想不做连接操作只能用UDP。

HTTP断点续传的基本原理
断点续传其实就是在上一次下载断开的位置开始继续下载，HTTP协议中，可以在请求报文头中加入Range段，来表示客户机希望从何处继续下载。
加入Range:bytes=1024-，表示从1024字节开始断点续传

27.netstat ：显示网络状态
tcpdump：截获通过本机网络接口的数据，用以分析。能够截获当前所有通过本机网卡的数据包。它拥有灵活的过滤机制，可以确保得到想要的数据。
ipcrm：手动解除系统上共享内存的分配
ipcs：报告系统的消息队列、信号量、共享内存等
列出所有的ipcs参数： -a,他是默认选项及ipcs等效于ipcs -a

[root@test ~]# ipcs -a

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status     
0x00000000 0          root       644        52         2                      
0x00000000 32769      root       644        16384      2                      
0x00000000 65538      root       644        268        2                      

------ Semaphore Arrays --------
key        semid      owner      perms      nsems    
0x00000000 0          root       600        1        
0x00000000 98305      root       600        1        
0x000000a7 131074     root       600        1        

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages

查看CPU信息   #cat /proc/cpuinfo 

查看内存信息   #cat /proc/meminfo  

查看硬盘分区信息   #df -lh

查看硬盘的型号信息  #cat /proc/scsi/scsi 


28.session和cache的区别是什么？
session是针对单个连接（会话）来使用的，主要存储和连接相关的上下文信息，比如登录信息等等。
cache是应用程序级的，主要用来缓存计算结果，减轻服务器负担，并加快响应速度。

29.http状态码中
2开头的表示成功，200表示访问成功
3开头的表示重定向
4开头的表示请求有误，400表示坏请求
5开头的表示服务器问题，500表示服务不可用