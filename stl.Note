stl
=

1.执行erase之后迭代器指向谁？（更多内容参考effective stl item 9）

list,vector,deque,string，指向紧接在被删元素之后的元素的有效迭代器

set,map,返回void



2.为何map和set的插入删除效率比用其他序列容器高？

对于关联容器来说，不需要做内存拷贝和内存移动。map和set容器内所有元素都是以节点的方式来存储。



3.为何map和set每次insert之后，以前保存的iterator不会失效？

iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢(当然被删除的那个元素本身已经失效了)。



4.为何map和set不能像vector一样有个reserve函数来预分配数据？

在map和set内部存储的不是元素本身，而是包含元素的节点。也就是说map内部使用的Alloc并不是map<Key, Data, Compare, Alloc>声明的时候从参数中传入的Alloc。例如：

map<int, int, less<int>, Alloc<int> > intmap;

在intmap中使用的allocator并不是Alloc<int>, 而是通过了转换的Alloc，具体转换的方法时在内部通过Alloc<int>::rebind重新定义了新的节点分配器，在map和set内面的分配器已经发生了变化，reserve方法你就不要奢望了。

备注：只有vector和string有reserve函数



5.当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？

在map和set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。



6.map和set如何中判断元素是否相等？

if(!(A<B || B<A))，当A<B和B<A都为假时，它们相等。



7.hash_map和map的区别在哪里？


构造函数。hash_map需要hash函数，等于函数；map只需要比较函数(小于函数).

存储结构。hash_map采用hash表存储，map一般采用红黑树(RB Tree)实现。因此其memory数据结构是不一样的。

哈希表中，实值的存储位置由其键值对应的哈希函数值决定。因此， 存储在哈希表中的值是无序的。在哈希表中插入元素和查找元素的时间复杂度都是O(1)。 (假设冲突很少)。实现一个哈希表，冲突处理是必须要考虑的。

对于STL中的map，键/值对在其中是根据键进行排序的。它使用一根红黑树来保存数据， 因此插入和查找元素的时间复杂度都是O(logn)。而且不需要处理冲突问题。



8. 什么时候需要用hash_map，什么时候需要用map?


hash_map 查找速度会比map快，属于常数级别;而map的查找速度是log(n)级别。并不一定常数就比log(n)小，hash还有hash函数的耗时，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑hash_map。但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，hash_map可能会让你陷入尴尬，特别是当你的hash_map对象特别多时，你就更无法控制了，而且hash_map的构造速度较慢。

权衡三个因素: 查找速度, 数据量, 内存使用。



9.哈希表是怎么实现的？


首先需要一个好的哈希函数来确保哈希值是均匀分布的。比如：对大质数取模

其次需要一个好的冲突解决方法：链表法(chaining，表中元素比较密集时用此法)， 探测法(probing，开放地址法，表中元素比较稀疏时用此法)。

动态地增加或减少哈希表的大小。比如，(表中元素数量)/(表大小)大于一个阈值时， 就增加哈希表的大小。我们新建一个大的哈希表，然后将旧表中的元素值， 通过新的哈希函数映射到新表。


10.解决哈希冲突有哪些方法？

开放定址法 
(1). 线性探测法 
(2). 平方探测法 
(3). 随机探测法
链地址法
公共溢出法
11.vector,list,deque比较？
vector的数据在内存中连续，随机存取元素的速度最快，在除尾部以外的位置删除或添加元素的速度很慢。 
list的数据是链式存储，所以不能随机存取元素。它的优势在于任意位置添加 删除元素的速度。 
deque模板是通过链接若干片连续的数据实现的，所以均衡了以上两个容器的特点

12.vector内存管理方式？


vector大小动态增长，以原来大小的两倍另外配置一块较大空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。

vector只是负责向内存管理框架acquire/release内存，内存管理框架如果发现内存不够了，就malloc，但是当vector释放资源的时候(比如destruct),stl不调用free，因为内存分配在stl的底层：stl假定如果你需要更多的资源就代表你以后也可能需要这么多资源(你的list, hashmap也是用这些内存)，所以就没必要不停地malloc/free。

一般的STL内存管理器allocator都是用内存池来管理内存的，所以某个容器申请内存或释放内存都只是影响到内存池的剩余内存量，而不是真的把内存归还给系统。这样做一是为了避免内存碎片，二是提高了内存申请和释放的效率——不用每次都在系统内存里寻找一番。真的让容器把不用的内存归还给系统的话，只能自己写一个allocator，并在容器的模板参数里使用它，而且STL的标准容器确实都留了这个接口。



13.仿函数

一种具有函数特质的对象， 也即可以像使用函数一样使用该对象。使得算法抽象性更高，也就更通用。 为什么不用函数指针？很简单的解释是抽象性不够，更进一步说是它无法配接，也就是可以将操作配接在一起变换为更复杂的操作（例如compose和bind1st等等方法），仿函数则可以轻松实现这些配接，使得其功能异常强大。


14.红黑树
二叉搜索树，接近平衡，一棵含有n个节点的红黑树的高度至多为2log(n+1).
红黑树的特性:
（1）每个节点或者是黑色，或者是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。
红黑树的插入:
（1）将红黑树当作一颗二叉查找树，将节点插入。
（2）将插入的节点着色为"红色"。
（3）通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。
被插入的节点是根节点。直接把此节点涂为黑色。
被插入的节点的父节点是黑色。什么也不需要做。节点被插入后，仍然是红黑树。
被插入的节点的父节点是红色。依据"叔叔节点的情况"，将这种情况进一步划分为3种情况(Case)。

现象说明	处理策略
Case 1	当前节点的父节点是红色，且当前节点的祖父节点的另一个子节点（叔叔节点）也是红色。	
(01) 将“父节点”设为黑色。
(02) 将“叔叔节点”设为黑色。
(03) 将“祖父节点”设为“红色”。
(04) 将“祖父节点”设为“当前节点”(红色节点)；即，之后继续对“当前节点”进行操作。

Case 2	当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的右孩子	
(01) 将“父节点”作为“新的当前节点”。
(02) 以“新的当前节点”为支点进行左旋。

Case 3	当前节点的父节点是红色，叔叔节点是黑色，且当前节点是其父节点的左孩子	
(01) 将“父节点”设为“黑色”。
(02) 将“祖父节点”设为“红色”。
(03) 以“祖父节点”为支点进行右旋。

红黑树的删除:
（1）将红黑树当作一颗二叉查找树，将节点删除。
（2）通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树。
前面我们将"删除红黑树中的节点"大致分为两步，在第一步中"将红黑树当作一颗二叉查找树，将节点删除"后，可能违反"特性(2)、(4)、(5)"三个特性。第二步需要解决上面的三个问题，进而保持红黑树的全部特性。
      为了便于分析，我们假设"x包含一个额外的黑色"(x原本的颜色还存在)，这样就不会违反"特性(5)"。为什么呢？
      通过RB-DELETE算法，我们知道：删除节点y之后，x占据了原来节点y的位置。 既然删除y(y是黑色)，意味着减少一个黑色节点；那么，再在该位置上增加一个黑色即可。这样，当我们假设"x包含一个额外的黑色"，就正好弥补了"删除y所丢失的黑色节点"，也就不会违反"特性(5)"。 因此，假设"x包含一个额外的黑色"(x原本的颜色还存在)，这样就不会违反"特性(5)"。
      现在，x不仅包含它原本的颜色属性，x还包含一个额外的黑色。即x的颜色属性是"红+黑"或"黑+黑"，它违反了"特性(1)"。

      现在，我们面临的问题，由解决"违反了特性(2)、(4)、(5)三个特性"转换成了"解决违反特性(1)、(2)、(4)三个特性"。RB-DELETE-FIXUP需要做的就是通过算法恢复红黑树的特性(1)、(2)、(4)。RB-DELETE-FIXUP的思想是：将x所包含的额外的黑色不断沿树上移(向根方向移动)，直到出现下面的姿态：
a) x指向一个"红+黑"节点。此时，将x设为一个"黑"节点即可。
b) x指向根。此时，将x设为一个"黑"节点即可。
c) 非前面两种姿态。

将上面的姿态，可以概括为3种情况。
① 情况说明：x是“红+黑”节点。
    处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。
② 情况说明：x是“黑+黑”节点，且x是根。
    处理方法：什么都不做，结束。此时红黑树性质全部恢复。
③ 情况说明：x是“黑+黑”节点，且x不是根。
    处理方法：这种情况又可以划分为4种子情况。这4种子情况如下表所示：

 	现象说明	处理策略
Case 1	x是"黑+黑"节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。	
(01) 将x的兄弟节点设为“黑色”。
(02) 将x的父节点设为“红色”。
(03) 对x的父节点进行左旋。
(04) 左旋后，重新设置x的兄弟节点。

Case 2	x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。	
(01) 将x的兄弟节点设为“红色”。
(02) 设置“x的父节点”为“新的x节点”。

Case 3	x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。	
(01) 将x兄弟节点的左孩子设为“黑色”。
(02) 将x兄弟节点设为“红色”。
(03) 对x的兄弟节点进行右旋。
(04) 右旋后，重新设置x的兄弟节点。

Case 4	x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。	
(01) 将x父节点颜色 赋值给 x的兄弟节点。
(02) 将x父节点设为“黑色”。
(03) 将x兄弟节点的右子节设为“黑色”。
(04) 对x的父节点进行左旋。
(05) 设置“x”为“根节点”。


